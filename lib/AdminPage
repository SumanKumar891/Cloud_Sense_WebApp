import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:fl_chart/fl_chart.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'DeviceGraphPage.dart';
import 'shareddevice.dart'; // Adjust path as needed

class AdminPage extends StatefulWidget {
  const AdminPage({Key? key}) : super(key: key);

  @override
  State<AdminPage> createState() => _AdminPageState();
}

class _AdminPageState extends State<AdminPage> {
  final String apiUrl =
      "https://xa9ry8sls0.execute-api.us-east-1.amazonaws.com/CloudSense_device_activity_api_function";
  final String userApiUrl =
      "https://25e5bsdhwd.execute-api.us-east-1.amazonaws.com/default/CloudSense_users_delete_function";
  final String flaggingApiUrl = "https://hmnrva928j.execute-api.us-east-1.amazonaws.com/default/WS_Flag_API";
  final String userDevicesApiUrl = "https://ln8b1r7ld9.execute-api.us-east-1.amazonaws.com/default/Cloudsense_user_devices";
  final String addDeviceApiUrl = "https://ymfmk699j5.execute-api.us-east-1.amazonaws.com/default/Cloudsense_user_add_devices";

  bool isLoading = true;
  List<Map<String, dynamic>> allDevices = [];
  int totalActive = 0;
  int totalInactive = 0;
  String filter = "All";
  String searchQuery = "";
  List<Map<String, String>> users = [];
  bool isUsersLoading = true;
  Map<String, String> anomalies = {};
  List<String> seenAnomalies = [];
  List<Map<String, String>> notifications = [];
  Timer? _anomalyTimer;
  FlutterLocalNotificationsPlugin? _notificationsPlugin;

  @override
  void initState() {
    super.initState();
    fetchDevices();
    fetchUsers();
    if (!kIsWeb) {
      _initializeNotifications();
    }
    fetchAnomalies();
    _anomalyTimer = Timer.periodic(Duration(seconds: 30), (_) => fetchAnomalies());
  }

  @override
  void dispose() {
    _anomalyTimer?.cancel();
    super.dispose();
  }

  Future<void> _initializeNotifications() async {
    _notificationsPlugin = FlutterLocalNotificationsPlugin();
    const androidInit = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosInit = DarwinInitializationSettings();
    const initSettings = InitializationSettings(android: androidInit, iOS: iosInit);
    await _notificationsPlugin!.initialize(
      initSettings,
      onDidReceiveNotificationResponse: (response) {
        if (response.payload != null) {
          _handleNotificationTap(response.payload!);
        }
      },
    );
  }

  Future<void> fetchAnomalies() async {
    final newNotifications = <Map<String, String>>[];
    for (final d in allDevices) {
      final deviceId = d['DeviceId'] ?? "";
      final topic = d['Topic'] ?? "Unknown";
      if (deviceId.isEmpty || !topic.contains('WS/Campus')) continue;
      final deviceIdTopic = "$deviceId#$topic";

      try {
        final response = await http.get(Uri.parse("$flaggingApiUrl?DeviceID=$deviceId"));
        if (response.statusCode == 200) {
          final data = json.decode(response.body);
          if (data is List && data.isNotEmpty) {
            final item = data.last;
            final anomaly = item['Anomaly']?.toString() ?? "";
            final timestamp = item['Timestamp']?.toString() ?? "N/A";
            if (anomaly.isNotEmpty) {
              anomalies[deviceIdTopic] = anomaly;
              if (!seenAnomalies.contains(deviceIdTopic)) {
                newNotifications.add({
                  'deviceIdTopic': deviceIdTopic,
                  'message': _buildNotificationMessage(deviceIdTopic, anomaly, timestamp),
                });
                seenAnomalies.add(deviceIdTopic);
              } else {
                final existingIndex = notifications.indexWhere((n) => n['deviceIdTopic'] == deviceIdTopic);
                if (existingIndex != -1) {
                  notifications[existingIndex]['message'] = _buildNotificationMessage(deviceIdTopic, anomaly, timestamp);
                }
              }
            }
          }
        } else {
          print("Flagging API error for $deviceId: ${response.statusCode}");
        }
      } catch (e) {
        print("Flagging API Exception for $deviceId: $e");
      }
    }

    if (newNotifications.isNotEmpty) {
      setState(() {
        notifications.insertAll(0, newNotifications);
        for (var notification in newNotifications) {
          _showNotification(notification['deviceIdTopic']!, notification['message']!);
        }
      });
    } else {
      setState(() {});
    }
  }

  String _buildNotificationMessage(String deviceIdTopic, String anomaly, String timestamp) {
    final deviceId = deviceIdTopic.split('#')[0];
    final topic = deviceIdTopic.split('#').length > 1 ? deviceIdTopic.split('#')[1] : "Unknown";
    final mapped = _mapCategoryAndPrefix(topic);
    final sensorName = mapped.prefix.isNotEmpty ? "${mapped.prefix}${deviceId.padLeft(3, '0')}" : deviceId;
    return "Anomaly in Device $sensorName: $anomaly at $timestamp";
  }

  Future<void> _showNotification(String deviceIdTopic, String message) async {
    if (kIsWeb) {
      return;
    } else {
      const androidDetails = AndroidNotificationDetails(
        'anomaly_channel',
        'Anomaly Alerts',
        channelDescription: 'Notifications for device anomalies',
        importance: Importance.high,
        priority: Priority.high,
      );
      const iosDetails = DarwinNotificationDetails();
      const platformDetails = NotificationDetails(android: androidDetails, iOS: iosDetails);
      await _notificationsPlugin!.show(
        deviceIdTopic.hashCode,
        'Device Anomaly',
        message,
        platformDetails,
        payload: deviceIdTopic,
      );
    }
  }

  void _handleNotificationTap(String deviceIdTopic) {
    final deviceId = deviceIdTopic.split('#')[0];
    final topic = deviceIdTopic.split('#').length > 1 ? deviceIdTopic.split('#')[1] : "Unknown";
    final device = filteredDevices.asMap().entries.firstWhere(
          (entry) => entry.value['DeviceId'] == deviceId && entry.value['Topic'] == topic,
          orElse: () => MapEntry(-1, {}),
        );
    if (device.key != -1) {
      final d = device.value;
      final mapped = _mapCategoryAndPrefix(topic);
      final sensorName = mapped.prefix.isNotEmpty ? "${mapped.prefix}${deviceId.padLeft(3, '0')}" : deviceId;
      final sequentialName = "${mapped.category}";
      final anomalyMessage = anomalies[deviceIdTopic] ?? "No anomaly data available";

      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: Text("Anomaly Details for $sensorName"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Device ID: $deviceId"),
              const SizedBox(height: 6),
              Text("Topic: $topic"),
              const SizedBox(height: 6),
              Text("Anomaly: $anomalyMessage"),
              const SizedBox(height: 6),
              Text("Last Received: ${d['lastReceivedTime']}"),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Close"),
            ),
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => DeviceGraphPage(
                      deviceName: sensorName,
                      sequentialName: sequentialName,
                      backgroundImagePath: 'assets/backgroundd.jpg',
                    ),
                  ),
                );
              },
              child: const Text("View Device"),
            ),
          ],
        ),
      );
    } else {
      _toast("Device not found for $deviceIdTopic");
    }
  }

  void _dismissNotification(String deviceIdTopic) {
    setState(() {
      notifications.removeWhere((n) => n['deviceIdTopic'] == deviceIdTopic);
      seenAnomalies.remove(deviceIdTopic);
      if (!kIsWeb) {
        _notificationsPlugin?.cancel(deviceIdTopic.hashCode);
      }
    });
  }

  void _showNotificationsDialog() {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;

    showDialog(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (dialogContext, dialogSetState) {
          return Dialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 400, maxHeight: 400),
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "Notifications (${notifications.length})",
                        style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800),
                      ),
                      IconButton(
                        icon: Icon(Icons.close, color: subtle),
                        onPressed: () => Navigator.pop(dialogContext),
                        tooltip: 'Close',
                      ),
                    ],
                  ),
                  const Divider(height: 1),
                  const SizedBox(height: 8),
                  Expanded(
                    child: notifications.isEmpty
                        ? Center(child: Text("No notifications", style: TextStyle(color: subtle)))
                        : Scrollbar(
                            thumbVisibility: true,
                            child: ListView.separated(
                              itemCount: notifications.length,
                              separatorBuilder: (_, __) => Divider(color: subtle.withOpacity(.12)),
                              itemBuilder: (_, i) {
                                final n = notifications[i];
                                final deviceIdTopic = n['deviceIdTopic']!;
                                return ListTile(
                                  leading: Icon(Icons.warning, color: Colors.orange),
                                  title: Text(
                                    n['message']!,
                                    style: TextStyle(color: strong, fontWeight: FontWeight.w600),
                                  ),
                                  trailing: IconButton(
                                    icon: Icon(Icons.delete, color: Colors.red),
                                    onPressed: () {
                                      dialogSetState(() {
                                        _dismissNotification(deviceIdTopic);
                                      });
                                    },
                                    tooltip: 'Dismiss',
                                  ),
                                  onTap: () {
                                    Navigator.pop(dialogContext);
                                    _handleNotificationTap(deviceIdTopic);
                                  },
                                );
                              },
                            ),
                          ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> fetchDevices() async {
    setState(() => isLoading = true);
    try {
      final response = await http.get(Uri.parse(apiUrl));
      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final keysToInclude = [
          'WS_Device_Activity',
          'Awadh_Jio_Device_Activity',
          'weather_Device_Activity',
        ];

        final List<Map<String, dynamic>> devices = [];
        for (final key in keysToInclude) {
          final list = data[key];
          if (list is List) {
            for (final device in list) {
              final topic = device['Topic']?.toString() ?? "Unknown";
              if (topic.startsWith('BF/') || topic.startsWith('CS/')) {
                continue;
              }
              final DateTime? lastTime = parseDate(device['lastReceivedTime']);
              bool isActive = false;
              if (lastTime != null) {
                final diff = DateTime.now().difference(lastTime);
                isActive = diff.inHours <= 24;
              }
              devices.add({
                "DeviceId": device['DeviceId']?.toString() ?? "Unknown",
                "lastReceivedTime": lastTime?.toString() ?? "N/A",
                "isActive": isActive,
                "group": key,
                "Topic": topic,
                "LastKnownLongitude": device['LastKnownLongitude']?.toString() ?? "0",
                "LastKnownLatitude": device['LastKnownLatitude']?.toString() ?? "0",
              });
            }
          }
        }

        final int activeCount = devices.where((d) => d['isActive'] == true).length;
        final int inactiveCount = devices.length - activeCount;

        setState(() {
          allDevices = devices;
          totalActive = activeCount;
          totalInactive = inactiveCount;
          isLoading = false;
        });
      } else {
        setState(() => isLoading = false);
        _toast("Device API error: ${response.statusCode}");
      }
    } catch (e) {
      setState(() => isLoading = false);
      _toast("Device fetch failed");
      if (kDebugMode) debugPrint("fetchDevices error: $e");
    }
  }

  Future<void> fetchUsers() async {
    setState(() => isUsersLoading = true);
    for (int attempt = 1; attempt <= 3; attempt++) {
      try {
        final response = await http.get(Uri.parse("$userApiUrl?action=list")).timeout(Duration(seconds: 10));
        if (response.statusCode == 200) {
          final data = json.decode(response.body);
          List<Map<String, String>> userList = [];

          if (data is Map && data.containsKey('users') && data['users'] is List) {
            userList = (data['users'] as List).map<Map<String, String>>((email) {
              return {
                "email": email.toString(),
                "name": email.toString().split('@')[0],
                "role": "User",
              };
            }).toList();
          }

          setState(() {
            users = userList;
            isUsersLoading = false;
          });

          if (users.isEmpty) {
            _toast("No valid user data received");
          }
          return;
        } else {
          if (attempt == 3) {
            setState(() => isUsersLoading = false);
            _toast("User API error: ${response.statusCode}");
            return;
          }
        }
      } catch (e) {
        if (attempt == 3) {
          setState(() => isUsersLoading = false);
          _toast("User fetch failed: $e");
        }
      }
      await Future.delayed(Duration(seconds: 2));
    }
  }

  Future<void> _showUserDevices(String email) async {
    Map<String, List<String>> deviceCategories = {};
    bool isLoadingDevices = true;

    try {
      final response = await http.get(Uri.parse("$userDevicesApiUrl?email_id=$email"));
      if (response.statusCode == 200) {
        final result = json.decode(response.body);
        deviceCategories = {
          for (var key in result.keys)
            if (key != 'device_id' && key != 'email_id')
              key: List<String>.from(result[key] ?? [])
        };
      } else {
        _toast("Failed to load devices: Status ${response.statusCode}");
      }
    } catch (e) {
      _toast("Error fetching devices: $e");
    } finally {
      isLoadingDevices = false;
    }

    if (!mounted) return;
    final isDark = Theme.of(context).brightness == Brightness.dark;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;

    showDialog(
      context: context,
      builder: (dialogContext) => StatefulBuilder(
        builder: (dialogContext, dialogSetState) {
          Future<void> _refreshDevices() async {
            dialogSetState(() => isLoadingDevices = true);
            try {
              final response = await http.get(Uri.parse("$userDevicesApiUrl?email_id=$email"));
              if (response.statusCode == 200) {
                final result = json.decode(response.body);
                dialogSetState(() {
                  deviceCategories = {
                    for (var key in result.keys)
                      if (key != 'device_id' && key != 'email_id')
                        key: List<String>.from(result[key] ?? [])
                  };
                });
              } else {
                _toast("Failed to load devices: Status ${response.statusCode}");
              }
            } catch (e) {
              _toast("Error fetching devices: $e");
            }
            dialogSetState(() => isLoadingDevices = false);
          }

          return Dialog(
            shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
            child: Container(
              constraints: const BoxConstraints(maxWidth: 600, maxHeight: 400),
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        "Devices for $email",
                        style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800),
                      ),
                      Row(
                        children: [
                          IconButton(
                            icon: Icon(Icons.refresh, color: subtle),
                            onPressed: _refreshDevices,
                            tooltip: 'Refresh',
                          ),
                          IconButton(
                            icon: Icon(Icons.close, color: subtle),
                            onPressed: () => Navigator.pop(dialogContext),
                          ),
                        ],
                      ),
                    ],
                  ),
                  const Divider(height: 1),
                  const SizedBox(height: 8),
                  Expanded(
                    child: isLoadingDevices
                        ? const Center(child: CircularProgressIndicator())
                        : deviceCategories.isEmpty
                            ? Center(child: Text("No devices found", style: TextStyle(color: subtle)))
                            : ListView.builder(
                                itemCount: deviceCategories.keys.length,
                                itemBuilder: (ctx, index) {
                                  final category = deviceCategories.keys.elementAt(index);
                                  final devices = deviceCategories[category]!;
                                  return ExpansionTile(
                                    title: Text(
                                      category.trim(),
                                      style: TextStyle(
                                        color: strong,
                                        fontWeight: FontWeight.bold,
                                        fontSize: 16,
                                      ),
                                    ),
                                    children: devices.map((device) {
                                      return ListTile(
                                        title: Text(
                                          '• $device',
                                          style: TextStyle(color: strong, fontSize: 14),
                                        ),
                                        trailing: IconButton(
                                          icon: Icon(Icons.delete, color: Colors.red),
                                          onPressed: () async {
                                            final confirm = await showDialog<bool>(
                                              context: dialogContext,
                                              builder: (confirmCtx) => AlertDialog(
                                                title: const Text("Confirm Deletion"),
                                                content: Text("Are you sure you want to delete device $device from $email?"),
                                                actions: [
                                                  TextButton(
                                                    onPressed: () => Navigator.pop(confirmCtx, false),
                                                    child: const Text("Cancel"),
                                                  ),
                                                  TextButton(
                                                    onPressed: () => Navigator.pop(confirmCtx, true),
                                                    child: const Text("Delete", style: TextStyle(color: Colors.red)),
                                                  ),
                                                ],
                                              ),
                                            );
                                            if (confirm == true) {
                                              await _deleteUserDevice(email, device, dialogContext, dialogSetState);
                                              // Check if there are any devices left
                                              if (deviceCategories.values.every((devices) => devices.isEmpty)) {
                                                Navigator.pop(dialogContext); // Close dialog if no devices remain
                                              } else {
                                                await _refreshDevices();
                                              }
                                            }
                                          },
                                          tooltip: 'Delete',
                                        ),
                                      );
                                    }).toList(),
                                  );
                                },
                              ),
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _deleteUserDevice(String email, String deviceId, BuildContext dialogContext, StateSetter dialogSetState) async {
    final url = "$userApiUrl?email_id=$email&action=delete_devices&device_id=$deviceId";
    try {
      final response = await http.delete(Uri.parse(url));
      if (response.statusCode == 200) {
        try {
          final body = json.decode(response.body);
          if (body['message']?.toString().toLowerCase().contains('deleted') == true) {
            _toast("Device $deviceId deleted from $email");
            // Remove any related notifications and anomalies
            final deviceIdTopic = allDevices
                .firstWhere((d) => d['DeviceId'] == deviceId, orElse: () => {'Topic': ''})['Topic']
                .toString();
            final fullDeviceIdTopic = "$deviceId#$deviceIdTopic";
            dialogSetState(() {
              notifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
              seenAnomalies.remove(fullDeviceIdTopic);
              anomalies.remove(fullDeviceIdTopic);
            });
            if (!kIsWeb) {
              _notificationsPlugin?.cancel(fullDeviceIdTopic.hashCode);
            }
          } else {
            _toast("Failed to delete device: ${body['message'] ?? 'Unknown error'}");
          }
        } on FormatException {
          if (response.body.toLowerCase().contains('deleted')) {
            _toast("Device $deviceId deleted from $email");
            final deviceIdTopic = allDevices
                .firstWhere((d) => d['DeviceId'] == deviceId, orElse: () => {'Topic': ''})['Topic']
                .toString();
            final fullDeviceIdTopic = "$deviceId#$deviceIdTopic";
            dialogSetState(() {
              notifications.removeWhere((n) => n['deviceIdTopic'] == fullDeviceIdTopic);
              seenAnomalies.remove(fullDeviceIdTopic);
              anomalies.remove(fullDeviceIdTopic);
            });
            if (!kIsWeb) {
              _notificationsPlugin?.cancel(fullDeviceIdTopic.hashCode);
            }
          } else {
            _toast("Failed to delete device: ${response.body}");
          }
        }
      } else {
        _toast("Delete API error: Status ${response.statusCode}, Body: ${response.body}");
      }
    } catch (e) {
      _toast("Error deleting device: $e");
      if (kDebugMode) print("Delete device error: $e");
    }
  }

  Future<void> _addDeviceToUser(String email, String deviceId) async {
    try {
      if (!DeviceUtils.isValidDeviceId(deviceId)) {
        _toast("Invalid Device ID.");
        return;
      }

      final deviceExists = allDevices.any((d) => d['DeviceId'] == deviceId);
      if (deviceExists) {
        _toast("Device $deviceId is already added.");
        return;
      }

      final response = await http.get(Uri.parse("$addDeviceApiUrl?email_id=$email&device_id=$deviceId"));
      if (kDebugMode) {
        print("Add Device Response: Status=${response.statusCode}, Body=${response.body}");
      }

      if (response.statusCode == 200) {
        try {
          final responseBody = json.decode(response.body);
          if (responseBody['message']?.toString().toLowerCase().contains('success') == true) {
            _toast("Device $deviceId added to $email successfully");
            // await fetchDevices();
            // await fetchAnomalies();
          } else {
            _toast("Failed to add device: ${responseBody['message'] ?? 'Unknown error'}");
          }
        } on FormatException {
          if (response.body.toLowerCase().contains('success')) {
            _toast("Device $deviceId added to $email successfully");
            // await fetchDevices();
            // await fetchAnomalies();
          } else {
            _toast("Failed to add device: ${response.body}");
          }
        }
      } else {
        _toast("Add device API error: Status ${response.statusCode}, ${response.body}");
      }
    } catch (e) {
      _toast("Error adding device: $e");
      if (kDebugMode) {
        print("Exception during device addition: $e");
      }
    }
  }

  void _showAddDeviceDialog(String email) {
    final TextEditingController deviceIdController = TextEditingController();

    showDialog(
      context: context,
      builder: (_) => StatefulBuilder(
        builder: (context, setState) {
          return AlertDialog(
            title: Text("Add Device to $email"),
            content: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                TextField(
                  controller: deviceIdController,
                  decoration: InputDecoration(
                    labelText: "Enter Device ID (e.g., CP001)",
                    border: OutlineInputBorder(),
                    helperText: "Use 2 uppercase letters (e.g., CP) + 3 digits (e.g., 001)",
                  ),
                  onChanged: (value) {
                    setState(() {});
                  },
                ),
              ],
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text("Cancel"),
              ),
              TextButton(
                onPressed: deviceIdController.text.trim().isEmpty
                    ? null
                    : () {
                        final deviceId = deviceIdController.text.trim();
                        if (!DeviceUtils.isValidDeviceId(deviceId)) {
                          _toast("Invalid Device ID.");
                          return;
                        }
                        Navigator.pop(context);
                        _addDeviceToUser(email, deviceId);
                      },
                child: const Text("Add"),
              ),
            ],
          );
        },
      ),
    );
  }

  DateTime? parseDate(String? dateStr) {
    if (dateStr == null) return null;
    try {
      final compactRegex = RegExp(r'^\d{8}T\d{6}$');
      if (compactRegex.hasMatch(dateStr)) {
        final y = int.parse(dateStr.substring(0, 4));
        final m = int.parse(dateStr.substring(4, 6));
        final d = int.parse(dateStr.substring(6, 8));
        final H = int.parse(dateStr.substring(9, 11));
        final M = int.parse(dateStr.substring(11, 13));
        final S = int.parse(dateStr.substring(13, 15));
        return DateTime(y, m, d, H, M, S);
      }
      return DateTime.tryParse(dateStr.replaceAll('  ', ' '));
    } catch (_) {
      return null;
    }
  }

  List<Map<String, dynamic>> get filteredDevices {
    Iterable<Map<String, dynamic>> list = allDevices;
    if (filter == "Active") {
      list = list.where((d) => d['isActive'] == true);
    } else if (filter == "Inactive") {
      list = list.where((d) => d['isActive'] == false);
    }
    if (searchQuery.isNotEmpty) {
      final q = searchQuery.toLowerCase();
      list = list.where((d) =>
          d['DeviceId'].toString().toLowerCase().contains(q) ||
          d['group'].toString().toLowerCase().contains(q) ||
          d['Topic'].toString().toLowerCase().contains(q));
    }
    final sorted = list.toList()
      ..sort((a, b) {
        if (a['isActive'] == b['isActive']) {
          return a['DeviceId'].toString().compareTo(b['DeviceId'].toString());
        }
        return a['isActive'] ? -1 : 1;
      });
    return sorted;
  }

  void _toast(String msg) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text(msg)));
  }

  ({String category, String prefix}) _mapCategoryAndPrefix(String topic) {
    if (topic == 'WS/Campus/2') {
      return (category: 'Sekhon Farm Sensor', prefix: 'CF');
    }
    if (topic.contains('WS/Campus')) {
      return (category: 'IIT Ropar Sensor', prefix: 'CP');
    }
    if (topic.contains('WS/SSMet/NARL')) {
      return (category: 'NARL Sensor', prefix: 'NA');
    }
    if (topic.contains('WS/SSMet/KJSCE')) {
      return (category: 'KJ Sensor', prefix: 'KJ');
    }
    if (topic.contains('WS/SSMet')) {
      return (category: 'SSMET Sensor', prefix: 'SM');
    }
    if (topic.contains('WS/SVPU')) {
      return (category: 'SVPU Sensor', prefix: 'SV');
    }
    if (topic.contains('WS/Mysuru')) {
      return (category: 'Mysuru NIE Sensor', prefix: 'MY');
    }
    if (topic.contains('WS/KARGIL')) {
      return (category: 'Kargil Sensor', prefix: 'KD');
    }
    if (topic.contains('IIT/WS')) {
      return (category: 'IIT Bombay Sensor', prefix: 'IT');
    }
    return (category: 'Unknown Sensor', prefix: '');
  }

  Future<void> _deleteUser(String email) async {
    final url = "$userApiUrl?email_id=$email&action=delete_user";
    try {
      final response = await http.delete(Uri.parse(url));
      if (response.statusCode == 200) {
        final responseBody = json.decode(response.body);
        if (responseBody is Map && responseBody['message']?.toString().toLowerCase().contains('confirm_delete=yes') == true) {
          if (!mounted) return;
          showDialog(
            context: context,
            builder: (_) => AlertDialog(
              title: const Text("Confirm Deletion"),
              content: Text("Are you sure you want to delete the user $email?"),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text("Cancel"),
                ),
                TextButton(
                  onPressed: () async {
                    Navigator.pop(context);
                    final confirmUrl = "$userApiUrl?email_id=$email&action=delete_user&confirm_delete=yes";
                    try {
                      final confirmResponse = await http.delete(Uri.parse(confirmUrl));
                      if (confirmResponse.statusCode == 200) {
                        final confirmResponseBody = json.decode(confirmResponse.body);
                        if (confirmResponseBody is Map && confirmResponseBody['message']?.toString().toLowerCase().contains('deleted') == true) {
                          _toast("User $email deleted successfully");
                          await fetchUsers();
                        } else {
                          _toast("Failed to delete user $email: ${confirmResponseBody['message'] ?? 'Unknown error'}");
                        }
                      } else if (confirmResponse.statusCode == 404) {
                        _toast("User $email not found, treated as deleted");
                        await fetchUsers();
                      } else {
                        _toast("Failed to delete user $email: Status ${confirmResponse.statusCode}");
                      }
                    } catch (e) {
                      _toast("Error deleting user $email: $e");
                      if (kDebugMode) debugPrint("confirmDeleteUser error: $e");
                    }
                  },
                  child: const Text("Delete", style: TextStyle(color: Colors.red)),
                ),
              ],
            ),
          );
        } else if (responseBody is Map && responseBody['message']?.toString().toLowerCase().contains('deleted') == true) {
          _toast("User $email deleted successfully");
          await fetchUsers();
        } else {
          _toast("Failed to delete user $email: ${responseBody['message'] ?? 'Unknown error'}");
        }
      } else if (response.statusCode == 404) {
        _toast("User $email not found, treated as deleted");
        await fetchUsers();
      } else {
        _toast("Failed to delete user $email: Status ${response.statusCode}");
      }
    } catch (e) {
      _toast("Error deleting user $email: $e");
      if (kDebugMode) debugPrint("deleteUser error: $e");
    }
  }

  List<PieChartSectionData> _pieSections() {
    final double active = (totalActive > 0) ? totalActive.toDouble() : 0;
    final double inactive = (totalInactive > 0) ? totalInactive.toDouble() : 0;
    final total = active + inactive;
    if (total == 0) {
      return [
        PieChartSectionData(
          color: Colors.grey.shade400,
          value: 1,
          title: 'No Data',
          radius: 46,
          titleStyle: TextStyle(fontSize: 12, color: Colors.white),
        )
      ];
    }
    return [
      PieChartSectionData(
        color: Colors.green,
        value: active,
        title: '${((active / total) * 100).toStringAsFixed(0)}%',
        radius: 48,
        titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
      ),
      PieChartSectionData(
        color: Colors.red,
        value: inactive,
        title: '${((inactive / total) * 100).toStringAsFixed(0)}%',
        radius: 48,
        titleStyle: const TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.white),
      ),
    ];
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final bg = isDark ? const Color(0xFF0F1115) : const Color(0xFFF3F5F7);
    final card = isDark ? const Color(0xFF161A22) : Colors.white;
    final subtle = isDark ? Colors.white70 : Colors.black54;
    final strong = isDark ? Colors.white : Colors.black;

    return Scaffold(
      backgroundColor: bg,
      appBar: AppBar(
        elevation: 0,
        backgroundColor: bg,
        leading: IconButton(
          icon: Icon(Icons.arrow_back, color: strong),
          onPressed: () => Navigator.pop(context),
        ),
        title: Text(
          'Admin Dashboard',
          style: TextStyle(
            color: strong,
            fontWeight: FontWeight.w700,
            letterSpacing: 0.2,
          ),
        ),
        actions: [
          if (kIsWeb)
            Stack(
              children: [
                IconButton(
                  tooltip: 'Notifications',
                  onPressed: _showNotificationsDialog,
                  icon: Icon(Icons.notifications, color: strong),
                ),
                if (notifications.isNotEmpty)
                  Positioned(
                    right: 8,
                    top: 8,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: Colors.red,
                        shape: BoxShape.circle,
                      ),
                      constraints: const BoxConstraints(minWidth: 16, minHeight: 16),
                      child: Text(
                        '${notifications.length}',
                        style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  ),
              ],
            ),
          IconButton(
            tooltip: 'Refresh devices',
            onPressed: () {
              fetchDevices();
              fetchAnomalies();
            },
            icon: Icon(Icons.refresh, color: strong),
          ),
        ],
      ),
      body: LayoutBuilder(
        builder: (context, constraints) {
          int statCrossAxisCount = (constraints.maxWidth > 1200) ? 4 : (constraints.maxWidth > 600) ? 2 : 1;
          int sectionCrossAxisCount = (constraints.maxWidth > 600) ? 2 : 1;

          return SingleChildScrollView(
            padding: EdgeInsets.all(constraints.maxWidth > 600 ? 18 : 12),
            child: Column(
              children: [
                GridView.count(
                  crossAxisCount: statCrossAxisCount,
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                  childAspectRatio: (constraints.maxWidth > 600) ? 2.6 : 3.8,
                  children: [
                    _StatCard(
                      title: "Total Devices",
                      value: allDevices.length.toString(),
                      icon: Icons.devices,
                      iconBg: Colors.blue,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Active",
                      value: totalActive.toString(),
                      icon: Icons.check_circle,
                      iconBg: Colors.green,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Inactive",
                      value: totalInactive.toString(),
                      icon: Icons.cancel,
                      iconBg: Colors.red,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                    _StatCard(
                      title: "Users",
                      value: users.length.toString(),
                      icon: Icons.people_alt,
                      iconBg: Colors.orange,
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                    ),
                  ],
                ),
                const SizedBox(height: 18),
                GridView.count(
                  crossAxisCount: sectionCrossAxisCount,
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  mainAxisSpacing: 16,
                  crossAxisSpacing: 16,
                  childAspectRatio: (constraints.maxWidth > 600) ? 1.8 : 1.0,
                  children: [
                    _SectionCard(
                      title: "Devices",
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,
                      child: isLoading
                          ? const Center(
                              child: Padding(
                                padding: EdgeInsets.all(24.0),
                                child: CircularProgressIndicator(),
                              ),
                            )
                          : LayoutBuilder(
                              builder: (context, constraints) {
                                int rows;
                                if (constraints.maxWidth > 900) {
                                  rows = 5;
                                } else if (constraints.maxWidth > 600) {
                                  rows = 3;
                                } else {
                                  rows = 2;
                                }

                                return Column(
                                  children: [
                                    Row(
                                      children: [
                                        _ChipFilter(
                                          value: filter,
                                          onChanged: (v) {
                                            setState(() => filter = v);
                                          },
                                          strong: strong,
                                          subtle: subtle,
                                          isDark: isDark,
                                        ),
                                        const SizedBox(width: 12),
                                        Expanded(
                                          child: _SearchField(
                                            hint: "Search device id, group, or topic...",
                                            onChanged: (q) => setState(() {
                                              searchQuery = q;
                                            }),
                                            strong: strong,
                                            subtle: subtle,
                                            isDark: isDark,
                                          ),
                                        ),
                                        const SizedBox(width: 8),
                                        IconButton(
                                          tooltip: "Refresh",
                                          onPressed: () {
                                            fetchDevices();
                                            fetchAnomalies();
                                          },
                                          icon: Icon(Icons.refresh, color: strong),
                                        ),
                                      ],
                                    ),
                                    const SizedBox(height: 10),
                                    const Divider(height: 1),
                                    const SizedBox(height: 8),
                                    ConstrainedBox(
                                      constraints: BoxConstraints(
                                        maxHeight: rows * 72.0,
                                      ),
                                      child: filteredDevices.isEmpty
                                          ? Center(
                                              child: Text("No devices found",
                                                  style: TextStyle(color: subtle)),
                                            )
                                          : SizedBox(
                                              height: rows * 72.0,
                                              child: ListView.separated(
                                                itemCount: filteredDevices.length,
                                                separatorBuilder: (_, __) =>
                                                    Divider(color: subtle.withOpacity(.12)),
                                                itemBuilder: (_, i) {
                                                  final d = filteredDevices[i];
                                                  final active = d['isActive'] == true;
                                                  final topic =
                                                      d['Topic']?.toString() ?? "Unknown";
                                                  final deviceId =
                                                      d['DeviceId']?.toString() ?? "Unknown";
                                                  final deviceIdTopic = "$deviceId#$topic";
                                                  final hasAnomaly =
                                                      anomalies.containsKey(deviceIdTopic);
                                                  final mapped = _mapCategoryAndPrefix(topic);
                                                  final sensorName = mapped.prefix.isNotEmpty
                                                      ? "${mapped.prefix}${deviceId.padLeft(3, '0')}"
                                                      : deviceId;
                                                  final sequentialName = "${mapped.category}";

                                                  return ListTile(
                                                    leading: _StatusDot(
                                                      color:
                                                          active ? Colors.green : Colors.red,
                                                    ),
                                                    title: Text(
                                                      "ID: $sensorName",
                                                      style: TextStyle(
                                                        color: strong,
                                                        fontWeight: FontWeight.w700,
                                                      ),
                                                      overflow: TextOverflow.ellipsis,
                                                      maxLines: 1,
                                                    ),
                                                    subtitle: Text(
                                                      "Name: $sequentialName\nLast: ${d['lastReceivedTime']}",
                                                      style: TextStyle(color: subtle),
                                                      overflow: TextOverflow.ellipsis,
                                                      maxLines: 2,
                                                    ),
                                                    trailing: Container(
                                                      padding: const EdgeInsets.symmetric(
                                                          horizontal: 10, vertical: 6),
                                                      decoration: BoxDecoration(
                                                        color: (active
                                                                ? Colors.green
                                                                : Colors.red)
                                                            .withOpacity(.12),
                                                        borderRadius: BorderRadius.circular(20),
                                                      ),
                                                      child: Text(
                                                        active ? "Active" : "Inactive",
                                                        style: TextStyle(
                                                          color: active
                                                              ? Colors.green
                                                              : Colors.red,
                                                          fontWeight: FontWeight.w700,
                                                        ),
                                                      ),
                                                    ),
                                                    onTap: () {
                                                      if (hasAnomaly) {
                                                        _handleNotificationTap(deviceIdTopic);
                                                      } else {
                                                        Navigator.push(
                                                          context,
                                                          MaterialPageRoute(
                                                            builder: (context) =>
                                                                DeviceGraphPage(
                                                              deviceName: sensorName,
                                                              sequentialName: sequentialName,
                                                              backgroundImagePath:
                                                                  'assets/backgroundd.jpg',
                                                            ),
                                                          ),
                                                        );
                                                      }
                                                    },
                                                  );
                                                },
                                              ),
                                            ),
                                    ),
                                  ],
                                );
                              },
                            ),
                    ),
                    _SectionCard(
                      title: "User Accounts",
                      cardColor: card,
                      strong: strong,
                      subtle: subtle,

                      child: isUsersLoading
                          ? const Center(
                              child: Padding(
                                padding: EdgeInsets.all(24.0),
                                child: CircularProgressIndicator(),
                              ),
                            )
                          : users.isNotEmpty
                              ? LayoutBuilder(
                                  builder: (context, constraints) {
                                    int rows;
                                    if (constraints.maxWidth > 900) {
                                      rows = 5;
                                    } else if (constraints.maxWidth > 600) {
                                      rows = 3;
                                    } else {
                                      rows = 2;
                                    }

                                    return Column(
                                      children: [
                                        Align(
                                          alignment: Alignment.centerLeft,
                                          child: Text(
                                            "Total ${users.length}",
                                            style: TextStyle(color: subtle),
                                          ),
                                        ),
                                        const SizedBox(height: 8),
                                        const Divider(height: 1),
                                        const SizedBox(height: 8),
                                        ConstrainedBox(
                                          constraints: BoxConstraints(
                                            maxHeight: rows * 72.0,
                                          ),
                                          child: SizedBox(
                                            height: rows * 72.0,
                                            child: ListView.separated(
                                              itemCount: users.length,
                                              separatorBuilder: (_, __) =>
                                                  Divider(color: subtle.withOpacity(.12)),
                                              itemBuilder: (_, i) {
                                                final u = users[i];
                                                return ListTile(
                                                  leading: CircleAvatar(
                                                    backgroundColor: Colors.blue.withOpacity(.12),
                                                    child: const Icon(Icons.person, color: Colors.blue),
                                                  ),
                                                  title: Text(
                                                    u["name"] ?? "",
                                                    style: TextStyle(
                                                      color: strong,
                                                      fontWeight: FontWeight.w700,
                                                    ),
                                                    overflow: TextOverflow.ellipsis,
                                                    maxLines: 1,
                                                  ),
                                                  subtitle: Text(
                                                    "${u["email"]} • ${u["role"]}",
                                                    style: TextStyle(color: subtle),
                                                    overflow: TextOverflow.ellipsis,
                                                    maxLines: 2,
                                                  ),
                                                  trailing: Row(
                                                    mainAxisSize: MainAxisSize.min,
                                                    children: [
                                                      IconButton(
                                                        tooltip: "Add Device",
                                                        onPressed: () =>
                                                            _showAddDeviceDialog(u["email"]!),
                                                        icon: const Icon(Icons.add, color: Colors.blue),
                                                      ),
                                                      IconButton(
                                                        tooltip: "Delete",
                                                        onPressed: () => _deleteUser(u["email"]!),
                                                        icon: const Icon(Icons.delete, color: Colors.red),
                                                      ),
                                                    ],
                                                  ),
                                                  onTap: () => _showUserDevices(u["email"]!),
                                                );
                                              },
                                            ),
                                          ),
                                        ),
                                      ],
                                    );
                                  },
                                )
                              : Center(
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Text("No users available", style: TextStyle(color: subtle)),
                                      const SizedBox(height: 8),
                                      ElevatedButton(
                                        onPressed: fetchUsers,
                                        child: const Text("Retry"),
                                      ),
                                    ],
                                  ),
                                ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                _SectionCard(
                  title: "Analytics",
                  cardColor: card,
                  strong: strong,
                  subtle: subtle,
                  child: Column(
                    children: [
                      const SizedBox(height: 6),
                      Card(
                        color: card,
                        elevation: 2,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: Column(
                            children: [
                              Align(
                                alignment: Alignment.centerLeft,
                                child: Text("Active vs Inactive", style: TextStyle(color: strong, fontWeight: FontWeight.w700)),
                              ),
                              const SizedBox(height: 8),
                              SizedBox(
                                height: constraints.maxWidth > 600 ? 160 : 120,
                                child: PieChart(
                                  PieChartData(
                                    sections: _pieSections(),
                                    centerSpaceRadius: 28,
                                    sectionsSpace: 2,
                                  ),
                                ),
                              ),
                              const SizedBox(height: 8),
                              Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  _LegendDot(color: Colors.green, text: "Active ($totalActive)"),
                                  const SizedBox(width: 12),
                                  _LegendDot(color: Colors.red, text: "Inactive ($totalInactive)"),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  void _showDeviceDetails(Map<String, dynamic> d) {
    showDialog(
      context: context,
      builder: (_) {
        final active = d['isActive'] == true;
        return AlertDialog(
          title: Text("Device ${d['DeviceId']}"),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text("Group: ${d['group']}"),
              const SizedBox(height: 6),
              Text("Topic: ${d['Topic']}"),
              const SizedBox(height: 6),
              Text("Last: ${d['lastReceivedTime']}"),
              const SizedBox(height: 6),
              Row(
                children: [
                  Text("Status: "),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
                    decoration: BoxDecoration(
                      color: (active ? Colors.green : Colors.red).withOpacity(.12),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      active ? "Active" : "Inactive",
                      style: TextStyle(color: active ? Colors.green : Colors.red, fontWeight: FontWeight.bold),
                    ),
                  ),
                ],
              ),
            ],
          ),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context), child: const Text("Close")),
          ],
        );
      },
    );
  }
}

class _StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color iconBg;
  final Color cardColor;
  final Color strong;
  final Color subtle;

  const _StatCard({
    required this.title,
    required this.value,
    required this.icon,
    required this.iconBg,
    required this.cardColor,
    required this.strong,
    required this.subtle,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: cardColor,
      elevation: 3,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(14)),
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Row(
          children: [
            Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(color: iconBg.withOpacity(.15), borderRadius: BorderRadius.circular(10)),
              child: Icon(icon, color: iconBg, size: 26),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(value, style: TextStyle(color: strong, fontSize: 20, fontWeight: FontWeight.w800)),
                  const SizedBox(height: 2),
                  Text(title, style: TextStyle(color: subtle, fontSize: 13)),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _SectionCard extends StatelessWidget {
  final String title;
  final Widget child;
  final Color cardColor;
  final Color strong;
  final Color subtle;

  const _SectionCard({
    required this.title,
    required this.child,
    required this.cardColor,
    required this.strong,
    required this.subtle,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      color: cardColor,
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: Padding(
        padding: const EdgeInsets.fromLTRB(14, 12, 14, 14),
        child: Column(
          children: [
            Row(
              children: [
                Text(title, style: TextStyle(color: strong, fontSize: 16, fontWeight: FontWeight.w800)),
              ],
            ),
            const SizedBox(height: 10),
            child,
          ],
        ),
      ),
    );
  }
}

class _ChipFilter extends StatelessWidget {
  final String value;
  final void Function(String) onChanged;
  final Color strong;
  final Color subtle;
  final bool isDark;

  const _ChipFilter({
    required this.value,
    required this.onChanged,
    required this.strong,
    required this.subtle,
    required this.isDark,
  });

  @override
  Widget build(BuildContext context) {
    final options = ["All", "Active", "Inactive"];
    return Wrap(
      spacing: 8,
      children: options.map((opt) {
        final selected = value == opt;
        return ChoiceChip(
          label: Text(
            opt,
            style: TextStyle(
              color: selected ? Colors.white : strong,
              fontWeight: FontWeight.w600,
            ),
          ),
          selected: selected,
          selectedColor: opt == "Active" ? Colors.green : (opt == "Inactive" ? Colors.red : Colors.blue),
          backgroundColor: (isDark ? Colors.white10 : Colors.black12).withOpacity(.06),
          onSelected: (_) => onChanged(opt),
        );
      }).toList(),
    );
  }
}

class _SearchField extends StatelessWidget {
  final String hint;
  final void Function(String) onChanged;
  final Color strong;
  final Color subtle;
  final bool isDark;

  const _SearchField({
    required this.hint,
    required this.onChanged,
    required this.strong,
    required this.subtle,
    required this.isDark,
  });

  @override
  Widget build(BuildContext context) {
    return TextField(
      onChanged: onChanged,
      style: TextStyle(color: strong),
      decoration: InputDecoration(
        prefixIcon: Icon(Icons.search, color: subtle),
        hintText: hint,
        hintStyle: TextStyle(color: subtle),
        filled: true,
        fillColor: (isDark ? Colors.white10 : Colors.black12).withOpacity(.06),
        contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: subtle.withOpacity(.2)),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: subtle.withOpacity(.15)),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Theme.of(context).colorScheme.primary, width: 1.2),
        ),
      ),
    );
  }
}

class _StatusDot extends StatelessWidget {
  final Color color;
  const _StatusDot({required this.color});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 14,
      height: 14,
      decoration: BoxDecoration(
        color: color,
        shape: BoxShape.circle,
        boxShadow: [BoxShadow(color: color.withOpacity(.35), blurRadius: 8, spreadRadius: 1)],
      ),
    );
  }
}

class _LegendDot extends StatelessWidget {
  final Color color;
  final String text;
  const _LegendDot({required this.color, required this.text});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(color: color, borderRadius: BorderRadius.circular(3)),
        ),
        const SizedBox(width: 6),
        Text(text, style: const TextStyle(fontWeight: FontWeight.w600)),
      ],
    );
  }
}